aufgabeben bis zum nächsten milestone
  - heute oder nächste woche zu erreichen
  - zeit ungenau, da aufwand für generatoren nur schwer einzuschätzen
  - milestone: alle polygon generatoren, shortest path generator

generatoren verwenden geometrische objekte
  - frameworks existent
  - für unsere aufgaben overkill
  - nur float oder double implementierungen -> um ungenauigkeiten zu vermeiden müssen wir 64bit integer verwenden (long)
  - imlementierungen nur mäßig effizient oder nicht konsistent
  -> eigene implementierung geometrischer objekte

algorithmen zur Generierung von simplen polygonen
  permute and reject (Auer, Held)
    eingabe: größe n oder n punkte
      0) erzeugt punkte, wenn notwendig
      1) permutiert punkte
      2) prüft ob diese simples polygon repräsentieren, wenn ja, dann ausgabe,
         wenn nein, dann 1)
         
    kann theoretisch ewig laufen
    für polygone mit max n=13
    erzeugt gleichverteilt und zu gewisser chance alle simplen polygone
         
  2opt.-move (Auer, Held)
    
    
  space partitioning (Auer, Held)
    
    
  incremental construction & backtracking (Auer, Held)
    
  velocity algorithm (O'Rourke, Virmani)
    eingabe: größe n, größe des kreises, maximale geschwindigkeit, schritte t
    1) erzeugt punkte, die auf einen kreis liegen -> (??regelmäßiges??)polygon
    2) bewegt jeden punkt mit zufälliger geschwindigkeit und richtung
    3) prüft, ob sich punkt danach über oder auf eine kante bewegt hätte, verwirft bewegung, wenn dies der fall wäre
    4) weiderhole 2 und 3 t mal
    
    laufzeit O(...)
    erzeugt zufällige polygone, sehen aber alle sehr gleich aus (bilder / zeigen)
    darüber in paper keine abhandlung
    
  random polygon algorithm (Dailey, Whitfield)
    eingabe: größe n
    1) erzeugt 3 zufällige punkte -> polygon
    2) n-3 mal:
      a) wählt eine kante AB aus, verwirft diese
      b) berechnet von AB aus sichtbaren bereich innerhalb des polygons
      c) wählt zufälligen punkt C im polygon
      d) fügt Kanten AC und BC ein
      
    große boilerplate
    berechnung des sichtbaren bereichs sehr komplex (-> fehlender test auf draussen oder drinnen)
    dementsprechend noch nicht fertig
  
  daraus resultierende algorithmische probleme
    polygone cc-wise <- nicht einfach zu überprüfen
    triangularisierung -> jetzt über trapezoierung gelöst (O(n log n))
    random point in polygon
    
  zunächst naiv implementierte probleme:
    schnitt polygon mit gerade
    fläche eines polygons
    

GUI
  demonstration
  TODOs:
    parametrisierung der algorithmen an GUI übergeben
    punkte markieren + eventuell ziehen
    skalen + markierung der maus
    spätere änderungen für statistik

damit der erste milestone noch nicht geschafft
  1 algo fehlt
  shortest path fehlt
  grund: unterschätzte boilerplate + seitentest, generell unterschätzter aufwand
  können jetzt trotzdem parallel mit neuen aufgaben beginnen
  
nächster: 
  - history
  - step by step visualisierung
  - backend für history
  
