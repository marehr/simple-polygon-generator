\section{Zusammenfassung}

  Nach Abschluss des Softwareprojekts lässt sich feststellen, dass wir insgesamt 
  die uns gestellten Ziele erreicht haben.
  Die entstandene Softwarelösung eignet sich zur
  massenweisen Erzeugung von zufälligen einfachen Polygonen, mit deren Hilfe
  sich verschiedenen Algorithmen der algorithmischen Geometrie testen und
  evaluieren lassen. Die verschiedenen Algorithmen führen indes zu äußerst
  unterschiedlichen Ergebnissen, von den vertikalen Linien des \emph{Space
  Partitioning}- bis hin zu den eher kreisförmigen Polygonen des
  \emph{Velocity Virmani}-Algorithmus. Zugleich bietet die graphische
  Oberfläche, insbesondere die graphische Visualisierung der Erzeugung der
  Polygone, einen interessanten Einblick in die Funktionsweise der
  Algorithmen.

  Im Laufe der Entwicklung konnten wir wertvolle Erfahrungen zu Teamarbeit und
  Prozesskoordination lernen. Hinsichtlich des Entwicklungsprozesses wurden die
  von uns festgelegte Vorgehensweise überwiegend konsequent eingehalten. Vor allem
  die Organisation in einer Gruppe von sechs Personen stellte sich als
  Herausforderung heraus. Die meisten unserer Entscheidungen wurden im Konsens
  getroffen, wodurch zwar die Erfahrung aller Mitglieder in die Softwarelösung
  einfließen konnte, jedoch führte dies mitunter zu langen Entscheidungsprozessen und
  einer teils inkonsistenten Umsetzung. Dies und die teils schwierige
  Koordination voneinander abhängiger Aufgaben bedingte einige Verzögerungen,
  der anfänglich aufgestellte Zeitplan wurde jedoch grob eingehalten.

  Als Fehlentscheidung ist hier die
  Entscheidung für die eigene Implementierung der generischen Polygon-
  Mathematik (und gegen ein entsprechendes Framework) zu bezeichnen. Zwar
  konnten wir uns so auf die tatsächlich benötigte Funktionalität (Schnitt-
  Test-Funktionen, Flächen-Berechnung, Orientierungstest, usw.) beschränken,
  jedoch konnten wir aufgrund des begrenzten Zeitraums oft nur naive
  Algorithmen einsetzen, sodass die Performanz der Algorithmen mitunter von
  langsamen Methoden im Framework dominiert wird. Beispielsweise erfolgt der
  Simplizitäts-Test beim Polygon (der Test auf Überschneidungs-Freiheit)
  in $\bigO(n^2)$, obwohl in der entsprechenden Fachliteratur effizientere
  Algorithmen beschrieben werden.

  Gleichzeitig stellten sich in den gegebenen Papers beschriebene Details und
  Abhängigkeiten zu den Algorithmen in der Implementierung mitunter als äussert
  schwierig heraus. Als beispielhafte Fehlentscheidung ist hierbei der Versuch
  zu nennen, einzig für die Initialisierung des \emph{Shortest Path}-Algorithmus
  einen Algorithmus zur Erzeugung einer Trapez-Zerlegung eines Polygons einzusetzen.
  Wir ver(sch)wendeten vergleichsweise viele Arbeitsstunden zur
  Implementierung eines überaus komplexen Algorithmus nach Raimund
  Seidel~\cite{seidel91asimple}, scheiterten hierbei mehrfach und fanden
  schließlich heraus, dass für die Initialisierung des SP-Algorithmus keine
  vollständige Trapez-Zerlegung benötigt wird. Die hierfür aufgebrachte Zeit hätte
  sinnvoller in eine höhere Testabdeckung investiert werden können, um die
  Robustheit der Software zu steigern.

  Da jedoch alle Ziele erreicht und interessante Erfahrungen gemacht wurden, lässt
  sich der Ausgang des Softwareprojekts in Summe als durchaus erfolgreich bewerten.

  \subsection{Lessons Learned}

  übericht über komplexe algorithmen, tiefgehendes verständniss oft noch nicht, obwohl man denkt man hats

  komplitkationen in implementierungsdetails

  organisation in gruppe & motivation oft nicht leicht, eine einzelne tonangebende person macht es wohl viel leichter

  hilfsmittel wie bugtracker ... benötigen zeit und gewöhnung, helfen nur, wenn sie konsequent durchgezogen werden
  
  testing benötigt zeit, lohnt sich aber (no shit :))

  \begin{lessonlearned}
    \emph{Malte} hat gelernt, dass österreicher Informatiker kluge 
    Algorithmen entwickeln können -- in der Theorie.
  \end{lessonlearned}

  \begin{lessonlearned}
    \emph{Bugs} hat gelernt, dass der böse Jäger eigentlich 
    ziemlich harmlos ist.
  \end{lessonlearned}
