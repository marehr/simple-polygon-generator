\section{Zusammenfassung}

  Nach Abschluss des Softwareprojekts lasst sich feststellen das wir insgesamt 
  die uns gestellten Ziele erreicht haben.
  Die entstandene Softwarelösung eignet sich zur
  massenweisen Erzeugung von zufälligen einfachen Polygonen, mit deren Hilfe
  sich verschiedenen Algorithmen der algorithmischen Geometrie testen und
  evaluieren lassen. Die verschiedenen Algorithmen führen indes zu äußerst
  unterschiedlichen Ergebnissen, von den vertikalen Linien des \emph{Space
  Partitioning}- bis hin zu den eher kreisförmigen Polygonen des
  \emph{Velocity Virmani}-Algorithmus. Zugleich bietet die graphische
  Oberfläche, insbesondere die graphische Visualisierung der Erzeugung der
  Polygone, einen interessanten Einblick in die Funktionsweise der
  Algorithmen.

  Im Laufe der Entwicklung konnten wir wertvolle Erfahrungen zu Teamarbeit und
  Prozesskoordination lernen. Hinsichtlich des Entwicklugsprozesses wurden die
  von uns festgelegt Vorgehensweise überwiegend konsequent eingehalten. Vorallem
  die Organisation in einer Gruppe von sechs Personen stellte sich als
  Herausvorderung heraus. Die meisten unserer Entscheidungen wurden im Konsens
  getroffen, wodurch zwar die Erfahrung aller Mitglieder in die Softwarelösung
  einfliessen konnte, jedoch gleichzeitig zu langen Entscheidungsprozessen und
  einer teils inkonsistenten Umsetzung führte. Dies und die teils schwierige
  Koordination voneinander abhängiger Aufgaben bedingte einige Verzögerungen,
  der anfänglich aufgestellte Zeitplan wurde jedoch grob eingehalten.

  Als Fehlentscheidung ist hier die
  Entscheidung für die eigene Implementierung der generischen Polygon-
  Mathematik (und gegen ein entsprechendes Framework) zu bezeichnen. Zwar
  konnten wir uns so auf die tatsächlich benötigte Funktionalität (Schnitt-
  Test-Funktionen, Flächen-Berechnung, Orientierungstest, usw.) beschränken,
  jedoch konnten wir aufgrund des begrenzten Zeitraum oft nur naive
  Algorithmen einsetzen, sodass die Performanz der Algorithmen mitunter von
  langsamen Methoden im Framework dominiert wird. Beispielsweise erfolgt der
  Simplizitäts-Test beim Polygon (d.h., der Test auf Überschneidungs-Freiheit)
  in $\bigO(n^2)$, obwohl in der entsprechenden Fachliteratur effizientere
  Algorithmen beschrieben werden.

  Gleichzeitig stellten sich in den gegebenen Papers beschriebene Details und
  Abhängigkeiten zu den Algorithmen in der Implementierung mitunter als äussert
  schwierig heraus. Als beispilehafte Fehlentscheidung ist hierbei der Versuch
  zu nennen, einzig für die Initialisierung des \emph{Shortest Path}-Algorithmus
  einen Algorithmus zur Erzeugung einer Trapez-Zerlegung eines Polygons zu
  verwenden. Wir verwendeten hierbei vergleichsweise viele Arbeitsstunden zur
  Implementierung eines überaus komplexen Algorithmus nach Raimund
  Seidel~\cite{seidel91asimple}, scheiterten hierbei mehrfach und fanden
  schließlich heraus, dass für die Initialisierung des SP-Algorithmus keine
  vollständige Trapez-Zerlegung benötigt wird. Hierfür verwendete Zeit hätte
  sinnvoller für eine höhere Testabdeckung verwendet werden können, um die
  Robustheit der Software zu steigern.

  bla weil ziele erreicht und tolle sachen hinsichtlich der entwicklung gelernt
  -> In Summe lässt sich der Ausgang des Softwareprojekts jedoch als durchaus
  erfolgreich bewerten.

  \subsection{Lessons Learned}

  \begin{lessonlearned}
    \emph{Malte} hat gelernt, dass österreicher Informatiker kluge 
    Algorithmen entwickeln können -- in der Theorie.
  \end{lessonlearned}

  \begin{lessonlearned}
    \emph{Bugs} hat gelernt, dass der böse Jäger eigentlich 
    ziemlich harmlos ist.
  \end{lessonlearned}
