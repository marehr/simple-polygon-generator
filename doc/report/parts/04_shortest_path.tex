\section{Shortest Path}
	%abbildung einfügen
	
Unsere Implementierung des Shortest-Path Algorithmus basiert auf dem Paper \enquote{Constant-Work-Space Algorithms For Geometric Problems} veröffentlicht 2011 im \enquote{Journal of Computational Geometry} von T. Asano, W. Mulzer, G. Rote und Y.Wang. 

\subsection{Algorithmus}

Allgemein benutzt der Algorithmus ein Tripel aus drei Punkten (p,q1,q2) um durch das Polygon zu navigieren. Es gilt, dass der Punkt p ein Punkt des Shortest-Path ist und das Polygon hinter q1, q2 den Zielpunkt (t) enthält.\\
Um dies zu erreichen wird zu Beginn das Polygon in Trapeze unterteilt. Vom Startpunkt aus wird ein Dreieck zu jeweils zwei benachbarten Eckpunkten des Trapezes aufgespannt und geprüft, ob das dahinter liegende Polygon den Zielpunkt enthält. Der triviale Fall, in dem sich der Zielpunkt im gleichen Trapez befindet wie der Startpunkt wird natürlich zu beginn überprüft.\\
Ausgehend von dem Trapez in dem der Startpunkt liegt wird das Polygon so reduziert, dass sich der Zielpunkt immer noch innerhalb des Polygons befindet. Um den nächsten Punkt des Shortest-Path zu finden wird die Krümmung von p,q1,succ(q1) bzw p,q2,pred(q2) betrachtet.

\subsection{Implementierung}

Bei der Implementierung konnten wir uns größten Teils an die Vorgaben des Paper halten. Allerdings mussten wir feststellen, dass sich das Unterteilen des Polygons in Trapeze als schwieriger herausstellte als zunächst angenommen. Schließlich entschieden wir uns auf die Unterteilung zu verzichten und stattdessen in einen etwas einfacheren Ansatz zu verwenden.\\
Die Initialisierung des Starttripel funktioniert folgender Maßen:

\begin{enumerate}
\item Finde alle Eckpunkte des Polygons, die direkt vom Startpunkt aus sichtbar sind.
\item Erzeuge von je zwei Eckpunkten und dem Startpunkt ein Subpolygon und überprüfe ob t darin liegt.
\item Falls t in dem Polygon liegt ist die Startkonfiguration gefunden. Andernfalls untersuche die nächsten zwei Punkte
\end{enumerate}

\subsection{Laufzeit}
\subsection{Stastiken}